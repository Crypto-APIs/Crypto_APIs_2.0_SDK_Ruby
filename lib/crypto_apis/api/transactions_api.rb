=begin
#CryptoAPIs

#Crypto APIs is a complex and innovative infrastructure layer that radically simplifies the development of any Blockchain and Crypto related applications. Organized around REST, Crypto APIs can assist both novice Bitcoin/Ethereum enthusiasts and crypto experts with the development of their blockchain applications. Crypto APIs provides unified endpoints and data, raw data, automatic tokens and coins forwardings, callback functionalities, and much more.

The version of the OpenAPI document: 2021-03-20
Contact: developers@cryptoapis.io
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.0.1-SNAPSHOT

=end

require 'cgi'

module CryptoApis
  class TransactionsApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create Coins Transaction From Address For Whole Amount
    # Through this endpoint customers can create a new transaction from address for **coins** specifically, which will transfer over the entire available amount.
    # @param address [String] Defines the source address.
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param wallet_id [String] Represents the sender&#39;s specific and unique Wallet ID of the sender.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateCoinsTransactionFromAddressForWholeAmountRB] :create_coins_transaction_from_address_for_whole_amount_rb 
    # @return [CreateCoinsTransactionFromAddressForWholeAmountR]
    def create_coins_transaction_from_address_for_whole_amount(address, blockchain, network, wallet_id, opts = {})
      data, _status_code, _headers = create_coins_transaction_from_address_for_whole_amount_with_http_info(address, blockchain, network, wallet_id, opts)
      data
    end

    # Create Coins Transaction From Address For Whole Amount
    # Through this endpoint customers can create a new transaction from address for **coins** specifically, which will transfer over the entire available amount.
    # @param address [String] Defines the source address.
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param wallet_id [String] Represents the sender&#39;s specific and unique Wallet ID of the sender.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateCoinsTransactionFromAddressForWholeAmountRB] :create_coins_transaction_from_address_for_whole_amount_rb 
    # @return [Array<(CreateCoinsTransactionFromAddressForWholeAmountR, Integer, Hash)>] CreateCoinsTransactionFromAddressForWholeAmountR data, response status code and response headers
    def create_coins_transaction_from_address_for_whole_amount_with_http_info(address, blockchain, network, wallet_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TransactionsApi.create_coins_transaction_from_address_for_whole_amount ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling TransactionsApi.create_coins_transaction_from_address_for_whole_amount"
      end
      # verify the required parameter 'blockchain' is set
      if @api_client.config.client_side_validation && blockchain.nil?
        fail ArgumentError, "Missing the required parameter 'blockchain' when calling TransactionsApi.create_coins_transaction_from_address_for_whole_amount"
      end
      # verify enum value
      allowable_values = ["ethereum", "ethereum-classic", "binance-smart-chain", "polygon"]
      if @api_client.config.client_side_validation && !allowable_values.include?(blockchain)
        fail ArgumentError, "invalid value for \"blockchain\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'network' is set
      if @api_client.config.client_side_validation && network.nil?
        fail ArgumentError, "Missing the required parameter 'network' when calling TransactionsApi.create_coins_transaction_from_address_for_whole_amount"
      end
      # verify enum value
      allowable_values = ["mainnet", "mordor", "testnet", "goerli", "mumbai"]
      if @api_client.config.client_side_validation && !allowable_values.include?(network)
        fail ArgumentError, "invalid value for \"network\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'wallet_id' is set
      if @api_client.config.client_side_validation && wallet_id.nil?
        fail ArgumentError, "Missing the required parameter 'wallet_id' when calling TransactionsApi.create_coins_transaction_from_address_for_whole_amount"
      end
      # resource path
      local_var_path = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{address}/all-transaction-requests'.sub('{' + 'address' + '}', CGI.escape(address.to_s)).sub('{' + 'blockchain' + '}', CGI.escape(blockchain.to_s)).sub('{' + 'network' + '}', CGI.escape(network.to_s)).sub('{' + 'walletId' + '}', CGI.escape(wallet_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'context'] = opts[:'context'] if !opts[:'context'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'create_coins_transaction_from_address_for_whole_amount_rb'])

      # return_type
      return_type = opts[:debug_return_type] || 'CreateCoinsTransactionFromAddressForWholeAmountR'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"TransactionsApi.create_coins_transaction_from_address_for_whole_amount",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TransactionsApi#create_coins_transaction_from_address_for_whole_amount\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Coins Transaction Request from Address
    # Through this endpoint users can create a new single transaction request from one address to another.
    # @param address [String] Defines the specific source address for the transaction. For XRP we also support the X-address format.
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param wallet_id [String] Represents the sender&#39;s specific and unique Wallet ID of the sender.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateCoinsTransactionRequestFromAddressRB] :create_coins_transaction_request_from_address_rb 
    # @return [CreateCoinsTransactionRequestFromAddressR]
    def create_coins_transaction_request_from_address(address, blockchain, network, wallet_id, opts = {})
      data, _status_code, _headers = create_coins_transaction_request_from_address_with_http_info(address, blockchain, network, wallet_id, opts)
      data
    end

    # Create Coins Transaction Request from Address
    # Through this endpoint users can create a new single transaction request from one address to another.
    # @param address [String] Defines the specific source address for the transaction. For XRP we also support the X-address format.
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param wallet_id [String] Represents the sender&#39;s specific and unique Wallet ID of the sender.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateCoinsTransactionRequestFromAddressRB] :create_coins_transaction_request_from_address_rb 
    # @return [Array<(CreateCoinsTransactionRequestFromAddressR, Integer, Hash)>] CreateCoinsTransactionRequestFromAddressR data, response status code and response headers
    def create_coins_transaction_request_from_address_with_http_info(address, blockchain, network, wallet_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TransactionsApi.create_coins_transaction_request_from_address ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling TransactionsApi.create_coins_transaction_request_from_address"
      end
      # verify the required parameter 'blockchain' is set
      if @api_client.config.client_side_validation && blockchain.nil?
        fail ArgumentError, "Missing the required parameter 'blockchain' when calling TransactionsApi.create_coins_transaction_request_from_address"
      end
      # verify enum value
      allowable_values = ["ethereum", "ethereum-classic", "binance-smart-chain", "xrp", "polygon"]
      if @api_client.config.client_side_validation && !allowable_values.include?(blockchain)
        fail ArgumentError, "invalid value for \"blockchain\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'network' is set
      if @api_client.config.client_side_validation && network.nil?
        fail ArgumentError, "Missing the required parameter 'network' when calling TransactionsApi.create_coins_transaction_request_from_address"
      end
      # verify enum value
      allowable_values = ["mainnet", "mordor", "testnet", "goerli", "mumbai"]
      if @api_client.config.client_side_validation && !allowable_values.include?(network)
        fail ArgumentError, "invalid value for \"network\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'wallet_id' is set
      if @api_client.config.client_side_validation && wallet_id.nil?
        fail ArgumentError, "Missing the required parameter 'wallet_id' when calling TransactionsApi.create_coins_transaction_request_from_address"
      end
      # resource path
      local_var_path = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{address}/transaction-requests'.sub('{' + 'address' + '}', CGI.escape(address.to_s)).sub('{' + 'blockchain' + '}', CGI.escape(blockchain.to_s)).sub('{' + 'network' + '}', CGI.escape(network.to_s)).sub('{' + 'walletId' + '}', CGI.escape(wallet_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'context'] = opts[:'context'] if !opts[:'context'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'create_coins_transaction_request_from_address_rb'])

      # return_type
      return_type = opts[:debug_return_type] || 'CreateCoinsTransactionRequestFromAddressR'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"TransactionsApi.create_coins_transaction_request_from_address",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TransactionsApi#create_coins_transaction_request_from_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Coins Transaction Request from Wallet
    # Through this endpoint users can create a new transaction request from the entire Wallet instead from just a specific address. This endpoint can generate transactions from multiple to multiple addresses.    {warning}This is available **only** for UTXO-based protocols such as Bitcoin, Bitcoin Cash, Litecoin, etc. It **is not** available for Account-based protocols like Ethereum.{/warning}
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param wallet_id [String] Represents the sender&#39;s specific and unique Wallet ID of the sender.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateCoinsTransactionRequestFromWalletRB] :create_coins_transaction_request_from_wallet_rb 
    # @return [CreateCoinsTransactionRequestFromWalletR]
    def create_coins_transaction_request_from_wallet(blockchain, network, wallet_id, opts = {})
      data, _status_code, _headers = create_coins_transaction_request_from_wallet_with_http_info(blockchain, network, wallet_id, opts)
      data
    end

    # Create Coins Transaction Request from Wallet
    # Through this endpoint users can create a new transaction request from the entire Wallet instead from just a specific address. This endpoint can generate transactions from multiple to multiple addresses.    {warning}This is available **only** for UTXO-based protocols such as Bitcoin, Bitcoin Cash, Litecoin, etc. It **is not** available for Account-based protocols like Ethereum.{/warning}
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param wallet_id [String] Represents the sender&#39;s specific and unique Wallet ID of the sender.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateCoinsTransactionRequestFromWalletRB] :create_coins_transaction_request_from_wallet_rb 
    # @return [Array<(CreateCoinsTransactionRequestFromWalletR, Integer, Hash)>] CreateCoinsTransactionRequestFromWalletR data, response status code and response headers
    def create_coins_transaction_request_from_wallet_with_http_info(blockchain, network, wallet_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TransactionsApi.create_coins_transaction_request_from_wallet ...'
      end
      # verify the required parameter 'blockchain' is set
      if @api_client.config.client_side_validation && blockchain.nil?
        fail ArgumentError, "Missing the required parameter 'blockchain' when calling TransactionsApi.create_coins_transaction_request_from_wallet"
      end
      # verify enum value
      allowable_values = ["bitcoin", "bitcoin-cash", "litecoin", "dogecoin", "dash", "zcash"]
      if @api_client.config.client_side_validation && !allowable_values.include?(blockchain)
        fail ArgumentError, "invalid value for \"blockchain\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'network' is set
      if @api_client.config.client_side_validation && network.nil?
        fail ArgumentError, "Missing the required parameter 'network' when calling TransactionsApi.create_coins_transaction_request_from_wallet"
      end
      # verify enum value
      allowable_values = ["mainnet", "testnet"]
      if @api_client.config.client_side_validation && !allowable_values.include?(network)
        fail ArgumentError, "invalid value for \"network\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'wallet_id' is set
      if @api_client.config.client_side_validation && wallet_id.nil?
        fail ArgumentError, "Missing the required parameter 'wallet_id' when calling TransactionsApi.create_coins_transaction_request_from_wallet"
      end
      # resource path
      local_var_path = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/transaction-requests'.sub('{' + 'blockchain' + '}', CGI.escape(blockchain.to_s)).sub('{' + 'network' + '}', CGI.escape(network.to_s)).sub('{' + 'walletId' + '}', CGI.escape(wallet_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'context'] = opts[:'context'] if !opts[:'context'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'create_coins_transaction_request_from_wallet_rb'])

      # return_type
      return_type = opts[:debug_return_type] || 'CreateCoinsTransactionRequestFromWalletR'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"TransactionsApi.create_coins_transaction_request_from_wallet",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TransactionsApi#create_coins_transaction_request_from_wallet\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Fungible Token Transaction Request From Address Without Fee Priority
    # Through this endpoint customers can make a single feeless token transaction on the Tron blockchain protocol. TRX transactions burn certain resources called Bandwidth and Energy. Each account has 1500 bandwidth free for use every 24 hours and more can be obtained by staking TRX. The unit price of Energy is 280 SUN and of bandwidth - 1000 SUN. If the resources are insufficient, TRX will be burned to pay for them.
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param sender_address [String] Defines the specific source address for the transaction.
    # @param wallet_id [String] Defines the unique ID of the Wallet.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRB] :create_fungible_token_transaction_request_from_address_without_fee_priority_rb 
    # @return [CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR]
    def create_fungible_token_transaction_request_from_address_without_fee_priority(blockchain, network, sender_address, wallet_id, opts = {})
      data, _status_code, _headers = create_fungible_token_transaction_request_from_address_without_fee_priority_with_http_info(blockchain, network, sender_address, wallet_id, opts)
      data
    end

    # Create Fungible Token Transaction Request From Address Without Fee Priority
    # Through this endpoint customers can make a single feeless token transaction on the Tron blockchain protocol. TRX transactions burn certain resources called Bandwidth and Energy. Each account has 1500 bandwidth free for use every 24 hours and more can be obtained by staking TRX. The unit price of Energy is 280 SUN and of bandwidth - 1000 SUN. If the resources are insufficient, TRX will be burned to pay for them.
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param sender_address [String] Defines the specific source address for the transaction.
    # @param wallet_id [String] Defines the unique ID of the Wallet.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRB] :create_fungible_token_transaction_request_from_address_without_fee_priority_rb 
    # @return [Array<(CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR, Integer, Hash)>] CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR data, response status code and response headers
    def create_fungible_token_transaction_request_from_address_without_fee_priority_with_http_info(blockchain, network, sender_address, wallet_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TransactionsApi.create_fungible_token_transaction_request_from_address_without_fee_priority ...'
      end
      # verify the required parameter 'blockchain' is set
      if @api_client.config.client_side_validation && blockchain.nil?
        fail ArgumentError, "Missing the required parameter 'blockchain' when calling TransactionsApi.create_fungible_token_transaction_request_from_address_without_fee_priority"
      end
      # verify enum value
      allowable_values = ["tron"]
      if @api_client.config.client_side_validation && !allowable_values.include?(blockchain)
        fail ArgumentError, "invalid value for \"blockchain\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'network' is set
      if @api_client.config.client_side_validation && network.nil?
        fail ArgumentError, "Missing the required parameter 'network' when calling TransactionsApi.create_fungible_token_transaction_request_from_address_without_fee_priority"
      end
      # verify enum value
      allowable_values = ["mainnet", "nile"]
      if @api_client.config.client_side_validation && !allowable_values.include?(network)
        fail ArgumentError, "invalid value for \"network\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'sender_address' is set
      if @api_client.config.client_side_validation && sender_address.nil?
        fail ArgumentError, "Missing the required parameter 'sender_address' when calling TransactionsApi.create_fungible_token_transaction_request_from_address_without_fee_priority"
      end
      # verify the required parameter 'wallet_id' is set
      if @api_client.config.client_side_validation && wallet_id.nil?
        fail ArgumentError, "Missing the required parameter 'wallet_id' when calling TransactionsApi.create_fungible_token_transaction_request_from_address_without_fee_priority"
      end
      # resource path
      local_var_path = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{senderAddress}/feeless-token-transaction-requests'.sub('{' + 'blockchain' + '}', CGI.escape(blockchain.to_s)).sub('{' + 'network' + '}', CGI.escape(network.to_s)).sub('{' + 'senderAddress' + '}', CGI.escape(sender_address.to_s)).sub('{' + 'walletId' + '}', CGI.escape(wallet_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'context'] = opts[:'context'] if !opts[:'context'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'create_fungible_token_transaction_request_from_address_without_fee_priority_rb'])

      # return_type
      return_type = opts[:debug_return_type] || 'CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"TransactionsApi.create_fungible_token_transaction_request_from_address_without_fee_priority",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TransactionsApi#create_fungible_token_transaction_request_from_address_without_fee_priority\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Fungible Tokens Transaction Request from Address
    # Through this endpoint users can make a single token transaction.    {note}To have an operational callback subscription, you need to first verify a domain for the Callback URL. Please see more information on Callbacks [here](https://developers.cryptoapis.io/technical-documentation/general-information/callbacks#callback-url).{/note}    {warning}Crypto APIs will notify the user **only when** the event occurs. There are cases when the specific event doesn't happen at all, or takes a long time to do so. A callback notification **will not** be sent if the event does not or cannot occur, or will take long time to occur.{/warning}
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param sender_address [String] Defines the specific source address for the transaction.
    # @param wallet_id [String] Defines the unique ID of the Wallet.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateFungibleTokensTransactionRequestFromAddressRB] :create_fungible_tokens_transaction_request_from_address_rb 
    # @return [CreateFungibleTokensTransactionRequestFromAddressR]
    def create_fungible_tokens_transaction_request_from_address(blockchain, network, sender_address, wallet_id, opts = {})
      data, _status_code, _headers = create_fungible_tokens_transaction_request_from_address_with_http_info(blockchain, network, sender_address, wallet_id, opts)
      data
    end

    # Create Fungible Tokens Transaction Request from Address
    # Through this endpoint users can make a single token transaction.    {note}To have an operational callback subscription, you need to first verify a domain for the Callback URL. Please see more information on Callbacks [here](https://developers.cryptoapis.io/technical-documentation/general-information/callbacks#callback-url).{/note}    {warning}Crypto APIs will notify the user **only when** the event occurs. There are cases when the specific event doesn&#39;t happen at all, or takes a long time to do so. A callback notification **will not** be sent if the event does not or cannot occur, or will take long time to occur.{/warning}
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param sender_address [String] Defines the specific source address for the transaction.
    # @param wallet_id [String] Defines the unique ID of the Wallet.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateFungibleTokensTransactionRequestFromAddressRB] :create_fungible_tokens_transaction_request_from_address_rb 
    # @return [Array<(CreateFungibleTokensTransactionRequestFromAddressR, Integer, Hash)>] CreateFungibleTokensTransactionRequestFromAddressR data, response status code and response headers
    def create_fungible_tokens_transaction_request_from_address_with_http_info(blockchain, network, sender_address, wallet_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TransactionsApi.create_fungible_tokens_transaction_request_from_address ...'
      end
      # verify the required parameter 'blockchain' is set
      if @api_client.config.client_side_validation && blockchain.nil?
        fail ArgumentError, "Missing the required parameter 'blockchain' when calling TransactionsApi.create_fungible_tokens_transaction_request_from_address"
      end
      # verify enum value
      allowable_values = ["ethereum", "ethereum-classic", "binance-smart-chain", "polygon"]
      if @api_client.config.client_side_validation && !allowable_values.include?(blockchain)
        fail ArgumentError, "invalid value for \"blockchain\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'network' is set
      if @api_client.config.client_side_validation && network.nil?
        fail ArgumentError, "Missing the required parameter 'network' when calling TransactionsApi.create_fungible_tokens_transaction_request_from_address"
      end
      # verify enum value
      allowable_values = ["mainnet", "mordor", "testnet", "goerli", "mumbai"]
      if @api_client.config.client_side_validation && !allowable_values.include?(network)
        fail ArgumentError, "invalid value for \"network\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'sender_address' is set
      if @api_client.config.client_side_validation && sender_address.nil?
        fail ArgumentError, "Missing the required parameter 'sender_address' when calling TransactionsApi.create_fungible_tokens_transaction_request_from_address"
      end
      # verify the required parameter 'wallet_id' is set
      if @api_client.config.client_side_validation && wallet_id.nil?
        fail ArgumentError, "Missing the required parameter 'wallet_id' when calling TransactionsApi.create_fungible_tokens_transaction_request_from_address"
      end
      # resource path
      local_var_path = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{senderAddress}/token-transaction-requests'.sub('{' + 'blockchain' + '}', CGI.escape(blockchain.to_s)).sub('{' + 'network' + '}', CGI.escape(network.to_s)).sub('{' + 'senderAddress' + '}', CGI.escape(sender_address.to_s)).sub('{' + 'walletId' + '}', CGI.escape(wallet_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'context'] = opts[:'context'] if !opts[:'context'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'create_fungible_tokens_transaction_request_from_address_rb'])

      # return_type
      return_type = opts[:debug_return_type] || 'CreateFungibleTokensTransactionRequestFromAddressR'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"TransactionsApi.create_fungible_tokens_transaction_request_from_address",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TransactionsApi#create_fungible_tokens_transaction_request_from_address\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Single Transaction Request From Address Without Fee Priority
    # Through this endpoint users can create a new single transaction request from one address to another. The difference between this endpoint and \"Create Coins Transaction Request from Address\"  is that for Tron blockchain there is no Fee Priority that defines how fast a transaction can be mined.
    # @param address [String] Defines the specific source address for the transaction.
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param wallet_id [String] Represents the sender&#39;s specific and unique Wallet ID of the sender.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateSingleTransactionRequestFromAddressWithoutFeePriorityRB] :create_single_transaction_request_from_address_without_fee_priority_rb 
    # @return [CreateSingleTransactionRequestFromAddressWithoutFeePriorityR]
    def create_single_transaction_request_from_address_without_fee_priority(address, blockchain, network, wallet_id, opts = {})
      data, _status_code, _headers = create_single_transaction_request_from_address_without_fee_priority_with_http_info(address, blockchain, network, wallet_id, opts)
      data
    end

    # Create Single Transaction Request From Address Without Fee Priority
    # Through this endpoint users can create a new single transaction request from one address to another. The difference between this endpoint and \&quot;Create Coins Transaction Request from Address\&quot;  is that for Tron blockchain there is no Fee Priority that defines how fast a transaction can be mined.
    # @param address [String] Defines the specific source address for the transaction.
    # @param blockchain [String] Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc.
    # @param network [String] Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks.
    # @param wallet_id [String] Represents the sender&#39;s specific and unique Wallet ID of the sender.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user.
    # @option opts [CreateSingleTransactionRequestFromAddressWithoutFeePriorityRB] :create_single_transaction_request_from_address_without_fee_priority_rb 
    # @return [Array<(CreateSingleTransactionRequestFromAddressWithoutFeePriorityR, Integer, Hash)>] CreateSingleTransactionRequestFromAddressWithoutFeePriorityR data, response status code and response headers
    def create_single_transaction_request_from_address_without_fee_priority_with_http_info(address, blockchain, network, wallet_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TransactionsApi.create_single_transaction_request_from_address_without_fee_priority ...'
      end
      # verify the required parameter 'address' is set
      if @api_client.config.client_side_validation && address.nil?
        fail ArgumentError, "Missing the required parameter 'address' when calling TransactionsApi.create_single_transaction_request_from_address_without_fee_priority"
      end
      # verify the required parameter 'blockchain' is set
      if @api_client.config.client_side_validation && blockchain.nil?
        fail ArgumentError, "Missing the required parameter 'blockchain' when calling TransactionsApi.create_single_transaction_request_from_address_without_fee_priority"
      end
      # verify enum value
      allowable_values = ["tron"]
      if @api_client.config.client_side_validation && !allowable_values.include?(blockchain)
        fail ArgumentError, "invalid value for \"blockchain\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'network' is set
      if @api_client.config.client_side_validation && network.nil?
        fail ArgumentError, "Missing the required parameter 'network' when calling TransactionsApi.create_single_transaction_request_from_address_without_fee_priority"
      end
      # verify enum value
      allowable_values = ["mainnet", "nile"]
      if @api_client.config.client_side_validation && !allowable_values.include?(network)
        fail ArgumentError, "invalid value for \"network\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'wallet_id' is set
      if @api_client.config.client_side_validation && wallet_id.nil?
        fail ArgumentError, "Missing the required parameter 'wallet_id' when calling TransactionsApi.create_single_transaction_request_from_address_without_fee_priority"
      end
      # resource path
      local_var_path = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{address}/feeless-transaction-requests'.sub('{' + 'address' + '}', CGI.escape(address.to_s)).sub('{' + 'blockchain' + '}', CGI.escape(blockchain.to_s)).sub('{' + 'network' + '}', CGI.escape(network.to_s)).sub('{' + 'walletId' + '}', CGI.escape(wallet_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'context'] = opts[:'context'] if !opts[:'context'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'create_single_transaction_request_from_address_without_fee_priority_rb'])

      # return_type
      return_type = opts[:debug_return_type] || 'CreateSingleTransactionRequestFromAddressWithoutFeePriorityR'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKey']

      new_options = opts.merge(
        :operation => :"TransactionsApi.create_single_transaction_request_from_address_without_fee_priority",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TransactionsApi#create_single_transaction_request_from_address_without_fee_priority\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
